<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terra Fatalis ‚Äî DPS Simulator</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        :root {
            --bg: #0a0a0f;
            --surface: #12121a;
            --card: #1a1a28;
            --card-hover: #22223a;
            --border: #2a2a40;
            --text: #e0e0f0;
            --text-dim: #8888aa;
            --text-muted: #555570;
            --accent: #7c5cfc;
            --accent2: #a78bfa;
            --accent-glow: rgba(124, 92, 252, .25);
            --kill: #22c55e;
            --kill-glow: rgba(34, 197, 94, .2);
            --survive: #ef4444;
            --survive-glow: rgba(239, 68, 68, .2);
            --gold: #f59e0b;
            --gold-glow: rgba(245, 158, 11, .15);
            --cyan: #06b6d4;
            --radius: 12px;
            --radius-lg: 16px;
        }

        html {
            font-size: 14px
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 24px 16px;
            background-image:
                radial-gradient(ellipse at 20% 0%, rgba(124, 92, 252, .08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(6, 182, 212, .06) 0%, transparent 50%);
        }

        h1 {
            font-size: 2rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 4px;
            background: linear-gradient(135deg, var(--accent2), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        .subtitle {
            text-align: center;
            color: var(--text-dim);
            font-size: .85rem;
            margin-bottom: 28px;
            font-weight: 300
        }

        .container {
            max-width: 900px;
            margin: 0 auto
        }

        /* Cards */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 16px;
            backdrop-filter: blur(12px);
            transition: border-color .2s;
        }

        .card:hover {
            border-color: rgba(124, 92, 252, .3)
        }

        .card-title {
            font-size: .8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent2);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-title::before {
            content: '';
            width: 3px;
            height: 14px;
            background: var(--accent);
            border-radius: 2px
        }

        /* Form */
        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px
        }

        .form-grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 14px
        }

        @media(max-width:600px) {

            .form-grid,
            .form-grid-3 {
                grid-template-columns: 1fr
            }
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px
        }

        .form-group.full {
            grid-column: 1/-1
        }

        label {
            font-size: .75rem;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: .8px
        }

        select,
        input[type="number"] {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            padding: 10px 14px;
            font-size: .9rem;
            font-family: 'Inter', sans-serif;
            outline: none;
            transition: border-color .2s, box-shadow .2s;
            -moz-appearance: textfield;
        }

        select:focus,
        input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow)
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238888aa'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 32px;
        }

        input::-webkit-inner-spin-button {
            opacity: 1
        }

        /* Toggles */
        .toggles {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 4px
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 10px 16px;
            cursor: pointer;
            user-select: none;
            transition: all .2s;
            flex: 1;
            min-width: 160px;
        }

        .toggle:hover {
            border-color: rgba(124, 92, 252, .3);
            background: var(--card-hover)
        }

        .toggle.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow)
        }

        .toggle-dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all .2s;
            flex-shrink: 0;
        }

        .toggle.active .toggle-dot {
            border-color: var(--accent);
            background: var(--accent)
        }

        .toggle.active .toggle-dot::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%
        }

        .toggle-label {
            font-size: .82rem;
            font-weight: 500;
            line-height: 1.3
        }

        .toggle-desc {
            font-size: .68rem;
            color: var(--text-muted);
            font-weight: 400
        }

        /* Weapon info */
        .weapon-info {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 10px;
            padding: 12px 16px;
            background: var(--surface);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .weapon-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px
        }

        .weapon-stat-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent2)
        }

        .weapon-stat-lbl {
            font-size: .65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: .5px;
            margin-top: 2px
        }

        /* Prop selectors */
        .prop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            margin-top: 14px
        }

        @media(max-width:600px) {
            .prop-grid {
                grid-template-columns: 1fr
            }
        }

        .prop-group label {
            margin-bottom: 4px;
            display: block
        }

        /* Button */
        .btn-simulate {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: .5px;
            background: linear-gradient(135deg, var(--accent), #6341e0);
            color: #fff;
            box-shadow: 0 4px 20px var(--accent-glow);
            transition: all .25s;
            text-transform: uppercase;
            margin-top: 8px;
        }

        .btn-simulate:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 30px rgba(124, 92, 252, .35)
        }

        .btn-simulate:active {
            transform: translateY(0)
        }

        /* Results */
        .results {
            display: none
        }

        .results.visible {
            display: block;
            animation: fadeUp .4s ease
        }

        @keyframes fadeUp {
            from {
                opacity: 0;
                transform: translateY(12px)
            }

            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        .verdict-bar {
            text-align: center;
            padding: 20px;
            border-radius: var(--radius-lg);
            margin-bottom: 16px;
            font-size: 1.6rem;
            font-weight: 900;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .verdict-bar.kill {
            background: var(--kill-glow);
            color: var(--kill);
            border: 1px solid rgba(34, 197, 94, .3)
        }

        .verdict-bar.survive {
            background: var(--survive-glow);
            color: var(--survive);
            border: 1px solid rgba(239, 68, 68, .3)
        }

        .verdict-sub {
            font-size: .75rem;
            font-weight: 400;
            opacity: .8;
            margin-top: 4px;
            letter-spacing: 0;
            text-transform: none
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 16px
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 14px;
            text-align: center;
        }

        .stat-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.3rem;
            font-weight: 700
        }

        .stat-val.accent {
            color: var(--accent2)
        }

        .stat-val.gold {
            color: var(--gold)
        }

        .stat-val.cyan {
            color: var(--cyan)
        }

        .stat-val.green {
            color: var(--kill)
        }

        .stat-val.red {
            color: var(--survive)
        }

        .stat-lbl {
            font-size: .65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: .5px;
            margin-top: 4px
        }

        /* Chart */
        .chart-wrap {
            position: relative;
            width: 100%;
            height: 240px;
            margin-top: 8px
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            border-radius: var(--radius)
        }

        /* Log */
        .combat-log {
            max-height: 200px;
            overflow-y: auto;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: .7rem;
            line-height: 1.7;
            color: var(--text-dim);
            margin-top: 12px;
        }

        .combat-log::-webkit-scrollbar {
            width: 6px
        }

        .combat-log::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px
        }

        .log-crit {
            color: #f59e0b;
            font-weight: 600
        }

        .log-heal {
            color: #22c55e
        }

        .log-kill {
            color: #ef4444;
            font-weight: 700
        }

        .log-absorb {
            color: var(--cyan)
        }

        .log-miss {
            color: #888;
            font-style: italic
        }

        .sim-count {
            font-size: .72rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 8px
        }

        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.92);
            backdrop-filter: blur(8px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 24px;
        }

        .loading-overlay.active {
            display: flex;
            animation: fadeIn .3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0
            }

            to {
                opacity: 1
            }
        }

        .loading-icon {
            font-size: 3.5rem;
            animation: pulse 1.2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.7;
            }

            50% {
                transform: scale(1.15);
                opacity: 1;
            }
        }

        .loading-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent2);
            letter-spacing: 1px;
        }

        .loading-sub {
            font-size: .8rem;
            color: var(--text-dim);
            font-weight: 300;
            margin-top: -12px;
        }

        .loading-bar-wrap {
            width: 280px;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), var(--cyan));
            border-radius: 3px;
            transition: width 0.15s linear;
        }

        .loading-percent {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent2), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .loading-details {
            font-family: 'JetBrains Mono', monospace;
            font-size: .7rem;
            color: var(--text-muted);
            text-align: center;
            line-height: 1.8;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>‚öîÔ∏è DPS Simulator</h1>
        <p class="subtitle">Sphere 51a Combat System ‚Äî Simula√ß√£o de 60 segundos</p>

        <!-- WEAPON SELECTION -->
        <div class="card">
            <div class="card-title">Arma</div>
            <div class="form-group full">
                <label>Buscar arma</label>
                <input type="text" id="weaponSearch" placeholder="üîç Digite para buscar... (ex: Halberd, Katana, Bow)"
                    autocomplete="off" style="margin-bottom:8px">
                <select id="weaponSelect" size="1"></select>
            </div>
            <div class="weapon-info" id="weaponInfo" style="display:none">
                <div class="weapon-stat"><span class="weapon-stat-val" id="wMin">-</span><span
                        class="weapon-stat-lbl">Min Dmg</span></div>
                <div class="weapon-stat"><span class="weapon-stat-val" id="wMax">-</span><span
                        class="weapon-stat-lbl">Max Dmg</span></div>
                <div class="weapon-stat"><span class="weapon-stat-val" id="wSpeed">-</span><span
                        class="weapon-stat-lbl">Speed</span></div>
                <div class="weapon-stat"><span class="weapon-stat-val" id="wSwing">-</span><span
                        class="weapon-stat-lbl">Swing (s)</span></div>
                <div class="weapon-stat"><span class="weapon-stat-val" id="wDps">-</span><span
                        class="weapon-stat-lbl">Raw DPS</span></div>
            </div>

            <!-- Weapon Properties -->
            <div class="prop-grid">
                <div class="form-group prop-group">
                    <label>Precis√£o (Accuracy)</label>
                    <select id="accuracyLevel">
                        <option value="0">Regular</option>
                        <option value="1">Accurate (+5)</option>
                        <option value="2">Surpassingly Accurate (+10)</option>
                        <option value="3">Eminently Accurate (+15)</option>
                        <option value="4">Exceedingly Accurate (+20)</option>
                        <option value="5">Supremely Accurate (+25)</option>
                    </select>
                </div>
                <div class="form-group prop-group">
                    <label>Dano (Damage Level)</label>
                    <select id="damageLevel">
                        <option value="0">Regular</option>
                        <option value="1">Ruin (+1.2)</option>
                        <option value="2">Might (+3.4)</option>
                        <option value="3">Force (+5.6)</option>
                        <option value="4">Power (+7.8)</option>
                        <option value="5">Vanquishing (+10.0)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- ATTACKER STATS -->
        <div class="card">
            <div class="card-title">Atacante</div>
            <div class="form-grid-3">
                <div class="form-group">
                    <label>DEX</label>
                    <input type="number" id="dexInput" min="1" max="150" value="100" step="1">
                </div>
                <div class="form-group">
                    <label>Weapon Skill</label>
                    <input type="number" id="weaponSkillInput" min="0" max="120" value="100" step="0.1">
                </div>
                <div class="form-group">
                    <label>Tactics</label>
                    <input type="number" id="tacticsInput" min="0" max="120" value="100" step="0.1">
                </div>
            </div>
            <div class="weapon-info" style="margin-top:14px" id="hitChanceInfo">
                <div class="weapon-stat"><span class="weapon-stat-val" id="hitChanceVal">-</span><span
                        class="weapon-stat-lbl">Hit Chance</span></div>
                <div class="weapon-stat"><span class="weapon-stat-val" id="effectiveSwing">-</span><span
                        class="weapon-stat-lbl">Swing (DEX)</span></div>
                <div class="weapon-stat"><span class="weapon-stat-val" id="effectiveDps">-</span><span
                        class="weapon-stat-lbl">Eff. DPS</span></div>
            </div>
        </div>

        <!-- TARGET CONFIG -->
        <div class="card">
            <div class="card-title">Alvo</div>
            <div class="form-grid">
                <div class="form-group">
                    <label>Armor Rating (AR)</label>
                    <input type="number" id="arInput" min="0" max="70" value="30" step="1">
                </div>
                <div class="form-group">
                    <label>HP do Alvo</label>
                    <input type="number" id="hpInput" min="1" max="9999" value="100" step="1">
                </div>
            </div>
        </div>

        <!-- BUFFS -->
        <div class="card">
            <div class="card-title">Buffs do Alvo</div>
            <div class="toggles">
                <div class="toggle" id="toggleProtection" onclick="toggleBuff('protection')">
                    <div class="toggle-dot"></div>
                    <div>
                        <div class="toggle-label">üõ°Ô∏è Protection</div>
                        <div class="toggle-desc">+10 AR bonus (GM Magery)</div>
                    </div>
                </div>
                <div class="toggle" id="toggleReactive" onclick="toggleBuff('reactive')">
                    <div class="toggle-dot"></div>
                    <div>
                        <div class="toggle-label">‚ö° Reactive Armor</div>
                        <div class="toggle-desc">Absorve 20% (pool: 10 HP)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- BANDAGES -->
        <div class="card">
            <div class="card-title">Bandagens</div>
            <div class="toggles">
                <div class="toggle" id="toggleBandage" onclick="toggleBuff('bandage')">
                    <div class="toggle-dot"></div>
                    <div>
                        <div class="toggle-label">ü©π Usar Bandagens</div>
                        <div class="toggle-desc">1 bandage a cada 10s ‚Äî cura 5~45 HP (GM)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SIMULATE -->
        <button class="btn-simulate" id="btnSimulate" onclick="runSimulation()">‚ñ∂ SIMULAR (60 segundos)</button>

        <!-- LOADING OVERLAY -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-icon">‚öîÔ∏è</div>
            <div class="loading-text">Simulando Combate...</div>
            <div class="loading-sub">1000 simula√ß√µes Monte Carlo</div>
            <div class="loading-percent" id="loadingPercent">0%</div>
            <div class="loading-bar-wrap">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
            <div class="loading-details" id="loadingDetails">Preparando...</div>
        </div>

        <!-- RESULTS -->
        <div class="results" id="results">
            <div class="verdict-bar" id="verdict"></div>
            <div class="stats-grid" id="statsGrid"></div>
            <div class="card">
                <div class="card-title">HP do Alvo ao longo do tempo</div>
                <div class="chart-wrap"><canvas id="hpChart"></canvas></div>
            </div>
            <div class="card">
                <div class="card-title">Log de Combate</div>
                <div class="combat-log" id="combatLog"></div>
                <div class="sim-count" id="simCount"></div>
            </div>
        </div>
    </div>

    <script>
        // ========== WEAPON DATABASE ==========
        const WEAPONS = [
            { cat: "Axes", name: "Axe", min: 18, max: 33, speed: 383 },
            { cat: "Axes", name: "BattleAxe", min: 18, max: 36, speed: 429 },
            { cat: "Axes", name: "DoubleAxe", min: 19, max: 36, speed: 401 },
            { cat: "Axes", name: "ExecutionersAxe", min: 24, max: 33, speed: 408 },
            { cat: "Axes", name: "Hatchet", min: 15, max: 28, speed: 342 },
            { cat: "Axes", name: "LargeBattleAxe", min: 22, max: 40, speed: 455 },
            { cat: "Axes", name: "Pickaxe", min: 1, max: 15, speed: 400 },
            { cat: "Axes", name: "TwoHandedAxe", min: 19, max: 41, speed: 430 },
            { cat: "Axes", name: "WarAxe", min: 13, max: 26, speed: 350 },
            { cat: "Knives", name: "ButcherKnife", min: 2, max: 5, speed: 200 },
            { cat: "Knives", name: "Cleaver", min: 2, max: 5, speed: 200 },
            { cat: "Knives", name: "Dagger", min: 1, max: 4, speed: 200 },
            { cat: "Knives", name: "SkinningKnife", min: 1, max: 10, speed: 362 },
            { cat: "Maces", name: "Club", min: 12, max: 19, speed: 302 },
            { cat: "Maces", name: "HammerPick", min: 20, max: 45, speed: 604 },
            { cat: "Maces", name: "Mace", min: 12, max: 33, speed: 441 },
            { cat: "Maces", name: "MagicWand", min: 2, max: 6, speed: 400 },
            { cat: "Maces", name: "Maul", min: 16, max: 29, speed: 431 },
            { cat: "Maces", name: "Scepter", min: 14, max: 17, speed: 450 },
            { cat: "Maces", name: "TrainingWand", min: 1, max: 5, speed: 312 },
            { cat: "Maces", name: "WarHammer", min: 29, max: 47, speed: 618 },
            { cat: "Maces", name: "WarMace", min: 14, max: 30, speed: 420 },
            { cat: "ML Weapons", name: "AssassinSpike", min: 8, max: 12, speed: 250 },
            { cat: "ML Weapons", name: "DiamondMace", min: 13, max: 21, speed: 380 },
            { cat: "ML Weapons", name: "ElvenCompositeLongbow", min: 16, max: 27, speed: 450 },
            { cat: "ML Weapons", name: "ElvenMachete", min: 13, max: 20, speed: 330 },
            { cat: "ML Weapons", name: "ElvenSpellblade", min: 12, max: 20, speed: 340 },
            { cat: "ML Weapons", name: "Leafblade", min: 11, max: 17, speed: 310 },
            { cat: "ML Weapons", name: "MagicalShortbow", min: 12, max: 18, speed: 320 },
            { cat: "ML Weapons", name: "OrnateAxe", min: 18, max: 29, speed: 380 },
            { cat: "ML Weapons", name: "RadiantScimitar", min: 13, max: 21, speed: 340 },
            { cat: "ML Weapons", name: "RuneBlade", min: 15, max: 26, speed: 400 },
            { cat: "ML Weapons", name: "WarCleaver", min: 10, max: 14, speed: 280 },
            { cat: "ML Weapons", name: "WildStaff", min: 14, max: 25, speed: 390 },
            { cat: "PoleArms", name: "Bardiche", min: 19, max: 48, speed: 516 },
            { cat: "PoleArms", name: "Halberd", min: 20, max: 57, speed: 616 },
            { cat: "PoleArms", name: "Scythe", min: 25, max: 39, speed: 475 },
            { cat: "Ranged", name: "Bow", min: 13, max: 20, speed: 338 },
            { cat: "Ranged", name: "CompositeBow", min: 15, max: 17, speed: 520 },
            { cat: "Ranged", name: "Crossbow", min: 14, max: 30, speed: 418 },
            { cat: "Ranged", name: "ElvenBow", min: 15, max: 21, speed: 265 },
            { cat: "Ranged", name: "HeavyCrossbow", min: 27, max: 39, speed: 683 },
            { cat: "Ranged", name: "RepeatingCrossbow", min: 10, max: 12, speed: 356 },
            { cat: "SE Weapons", name: "Bokuto", min: 10, max: 14, speed: 298 },
            { cat: "SE Weapons", name: "Daisho", min: 13, max: 20, speed: 362 },
            { cat: "SE Weapons", name: "Kama", min: 11, max: 15, speed: 290 },
            { cat: "SE Weapons", name: "Lajatang", min: 14, max: 18, speed: 290 },
            { cat: "SE Weapons", name: "NoDachi", min: 18, max: 25, speed: 400 },
            { cat: "SE Weapons", name: "Nunchaku", min: 12, max: 16, speed: 323 },
            { cat: "SE Weapons", name: "Sai", min: 10, max: 14, speed: 290 },
            { cat: "SE Weapons", name: "Tekagi", min: 11, max: 15, speed: 298 },
            { cat: "SE Weapons", name: "Tessen", min: 11, max: 15, speed: 310 },
            { cat: "SE Weapons", name: "Tetsubo", min: 13, max: 17, speed: 333 },
            { cat: "SE Weapons", name: "Wakizashi", min: 12, max: 18, speed: 338 },
            { cat: "SE Weapons", name: "Yumi", min: 20, max: 28, speed: 520 },
            { cat: "SpearsAndForks", name: "BladedStaff", min: 14, max: 16, speed: 383 },
            { cat: "SpearsAndForks", name: "DoubleBladedStaff", min: 12, max: 13, speed: 314 },
            { cat: "SpearsAndForks", name: "Pike", min: 14, max: 16, speed: 383 },
            { cat: "SpearsAndForks", name: "Pitchfork", min: 4, max: 16, speed: 333 },
            { cat: "SpearsAndForks", name: "ShortSpear", min: 15, max: 29, speed: 306 },
            { cat: "SpearsAndForks", name: "Spear", min: 15, max: 34, speed: 351 },
            { cat: "SpearsAndForks", name: "TribalSpear", min: 13, max: 30, speed: 362 },
            { cat: "SpearsAndForks", name: "WarFork", min: 16, max: 27, speed: 390 },
            { cat: "Staves", name: "BlackStaff", min: 15, max: 33, speed: 391 },
            { cat: "Staves", name: "GnarledStaff", min: 14, max: 33, speed: 392 },
            { cat: "Staves", name: "QuarterStaff", min: 9, max: 35, speed: 355 },
            { cat: "Staves", name: "ShepherdsCrook", min: 3, max: 12, speed: 450 },
            { cat: "Swords", name: "BoneHarvester", min: 13, max: 15, speed: 391 },
            { cat: "Swords", name: "Broadsword", min: 10, max: 25, speed: 334 },
            { cat: "Swords", name: "CrescentBlade", min: 11, max: 14, speed: 323 },
            { cat: "Swords", name: "Cutlass", min: 12, max: 24, speed: 332 },
            { cat: "Swords", name: "Katana", min: 13, max: 24, speed: 331 },
            { cat: "Swords", name: "Kryss", min: 11, max: 18, speed: 248 },
            { cat: "Swords", name: "Lance", min: 17, max: 18, speed: 537 },
            { cat: "Swords", name: "Longsword", min: 13, max: 30, speed: 401 },
            { cat: "Swords", name: "Scimitar", min: 12, max: 25, speed: 342 },
            { cat: "Swords", name: "ThinLongsword", min: 8, max: 34, speed: 396 },
            { cat: "Swords", name: "VikingSword", min: 12, max: 35, speed: 442 },
            { cat: "Weapons", name: "Fists", min: 1, max: 8, speed: 220 }
        ];

        // ========== STATE ==========
        let buffs = { protection: false, reactive: false, bandage: false };

        // ========== HELPERS ==========
        function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }
        function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

        // ========== DEX SWING SPEED (SphereCombat.GetDelay) ==========
        function getSwingTime(baseSpeed, dex) {
            let speedInSeconds = baseSpeed / 100.0 * 0.65; // SpeedMultiplier from SphereConfiguration = 0.65
            const bonusDex = clamp(dex - 100, -50, 25);
            if (bonusDex > 0) {
                speedInSeconds -= speedInSeconds * bonusDex * 0.008;
            } else if (bonusDex < 0) {
                speedInSeconds -= speedInSeconds * bonusDex * 0.004;
            }
            return Math.max(0.25, speedInSeconds);
        }

        // ========== HIT CHANCE (SphereCombat.CheckHit) ==========
        function getHitChance(weaponSkill, tactics, accuracyLevel) {
            const accuracyBonus = accuracyLevel * 5;
            return 0.69 * ((weaponSkill + accuracyBonus + tactics * 2) / 300.0);
        }

        // ========== DAMAGE BONUS (SphereCombat.ScaleDamage) ==========
        function getDamageBonus(damageLevel) {
            if (damageLevel === 0) return 0;
            return 2.2 * damageLevel - 1;
        }

        // ========== INIT ==========
        function initWeaponSelect() {
            const sel = document.getElementById('weaponSelect');
            const cats = [...new Set(WEAPONS.map(w => w.cat))];
            cats.forEach(cat => {
                const og = document.createElement('optgroup');
                og.label = cat;
                WEAPONS.filter(w => w.cat === cat).forEach(w => {
                    const o = document.createElement('option');
                    o.value = WEAPONS.indexOf(w);
                    o.textContent = w.name;
                    og.appendChild(o);
                });
                sel.appendChild(og);
            });
            const halbIdx = WEAPONS.findIndex(w => w.name === 'Halberd');
            if (halbIdx >= 0) sel.value = halbIdx;

            sel.addEventListener('change', updateWeaponInfo);
            document.getElementById('dexInput').addEventListener('input', updateWeaponInfo);
            document.getElementById('weaponSkillInput').addEventListener('input', updateWeaponInfo);
            document.getElementById('tacticsInput').addEventListener('input', updateWeaponInfo);
            document.getElementById('accuracyLevel').addEventListener('change', updateWeaponInfo);
            document.getElementById('damageLevel').addEventListener('change', updateWeaponInfo);

            // Weapon search
            document.getElementById('weaponSearch').addEventListener('input', filterWeapons);

            updateWeaponInfo();
        }

        function filterWeapons() {
            const query = document.getElementById('weaponSearch').value.toLowerCase().trim();
            const sel = document.getElementById('weaponSelect');
            const currentVal = sel.value;

            // Clear existing options
            sel.innerHTML = '';

            const cats = [...new Set(WEAPONS.map(w => w.cat))];
            let firstMatch = null;

            cats.forEach(cat => {
                const filtered = WEAPONS.filter(w => w.cat === cat &&
                    (query === '' || w.name.toLowerCase().includes(query) || cat.toLowerCase().includes(query)));
                if (filtered.length === 0) return;

                const og = document.createElement('optgroup');
                og.label = cat;
                filtered.forEach(w => {
                    const o = document.createElement('option');
                    o.value = WEAPONS.indexOf(w);
                    o.textContent = w.name;
                    if (firstMatch === null) firstMatch = o.value;
                    og.appendChild(o);
                });
                sel.appendChild(og);
            });

            // Try to keep current selection, otherwise pick first match
            if (sel.querySelector(`option[value="${currentVal}"]`)) {
                sel.value = currentVal;
            } else if (firstMatch !== null) {
                sel.value = firstMatch;
            }

            updateWeaponInfo();
        }

        function updateWeaponInfo() {
            const w = WEAPONS[document.getElementById('weaponSelect').value];
            if (!w) return;

            const dex = parseInt(document.getElementById('dexInput').value) || 100;
            const weaponSkill = parseFloat(document.getElementById('weaponSkillInput').value) || 100;
            const tactics = parseFloat(document.getElementById('tacticsInput').value) || 100;
            const accuracyLvl = parseInt(document.getElementById('accuracyLevel').value) || 0;
            const damageLvl = parseInt(document.getElementById('damageLevel').value) || 0;

            document.getElementById('weaponInfo').style.display = 'flex';

            // Base stats
            const dmgBonus = getDamageBonus(damageLvl);
            document.getElementById('wMin').textContent = w.min;
            document.getElementById('wMax').textContent = w.max + (dmgBonus > 0 ? ` (+${dmgBonus.toFixed(1)})` : '');
            document.getElementById('wSpeed').textContent = w.speed;

            // Base swing (with SpeedMultiplier 0.65)
            const baseSwing = w.speed / 100 * 0.65;
            document.getElementById('wSwing').textContent = baseSwing.toFixed(2);
            const avgDmg = (w.min + w.max) / 2 + dmgBonus;
            document.getElementById('wDps').textContent = (avgDmg / baseSwing).toFixed(1);

            // DEX-adjusted swing
            const effSwing = getSwingTime(w.speed, dex);
            document.getElementById('effectiveSwing').textContent = effSwing.toFixed(2) + 's';

            // Hit chance
            const hitChance = getHitChance(weaponSkill, tactics, accuracyLvl);
            document.getElementById('hitChanceVal').textContent = (Math.min(hitChance, 1) * 100).toFixed(1) + '%';

            // Effective DPS (avg dmg * hit chance / swing time)
            const effDps = (avgDmg * Math.min(hitChance, 1)) / effSwing;
            document.getElementById('effectiveDps').textContent = effDps.toFixed(1);
        }

        function toggleBuff(name) {
            buffs[name] = !buffs[name];
            const el = document.getElementById('toggle' + name.charAt(0).toUpperCase() + name.slice(1));
            el.classList.toggle('active', buffs[name]);
        }

        // ========== SIMULATION ENGINE ==========
        function simulateOnce(weapon, ar, targetHP, dex, weaponSkill, tactics, accuracyLvl, damageLvl) {
            const DURATION = 60;
            const BANDAGE_INTERVAL = 10;
            const CRIT_CHANCE = 0.05;

            const swingTime = getSwingTime(weapon.speed, dex);
            const hitChance = getHitChance(weaponSkill, tactics, accuracyLvl);
            const dmgBonus = getDamageBonus(damageLvl);

            // Protection: +10 AR (GM Magery = 100 ‚Üí 6 + 100*4/100 = 10)
            let effectiveAR = ar;
            if (buffs.protection) effectiveAR += 10;

            // Reactive Armor pool
            let reactivePool = buffs.reactive ? 10 : 0;

            let hp = targetHP;
            let time = 0;
            let totalDamage = 0;
            let totalHealed = 0;
            let totalMitigated = 0;
            let totalCrits = 0;
            let totalSwings = 0;
            let totalHits = 0;
            let totalMisses = 0;
            let totalReactiveAbsorbed = 0;
            let consecutiveMisses = 0;

            const log = [];
            const hpTimeline = [{ t: 0, hp: hp }];

            let nextSwing = swingTime;
            let nextBandage = buffs.bandage ? BANDAGE_INTERVAL : Infinity;

            while (time < DURATION && hp > 0) {
                const nextEvent = Math.min(nextSwing, nextBandage);
                if (nextEvent > DURATION) break;
                time = nextEvent;

                // Process swing
                if (Math.abs(time - nextSwing) < 0.001 && time <= DURATION) {
                    totalSwings++;

                    // Hit check with pity system
                    const pityBonus = consecutiveMisses * 0.05;
                    const effectiveHitChance = Math.min(hitChance + pityBonus, 1.0);
                    const hit = Math.random() <= effectiveHitChance;

                    if (!hit) {
                        totalMisses++;
                        consecutiveMisses++;
                        log.push({ t: time, type: 'miss', chance: effectiveHitChance });
                        nextSwing += swingTime;
                        // Check if bandage happens at same time
                        if (Math.abs(time - nextBandage) < 0.001 && time <= DURATION && hp > 0) {
                            const healAmount = randInt(5, 45);
                            const actualHeal = Math.min(healAmount, targetHP - hp);
                            hp += actualHeal;
                            totalHealed += actualHeal;
                            log.push({ t: time, type: 'heal', heal: actualHeal });
                            hpTimeline.push({ t: time, hp: hp });
                            nextBandage += BANDAGE_INTERVAL;
                        }
                        continue;
                    }

                    // Hit! Reset pity
                    totalHits++;
                    consecutiveMisses = 0;

                    let damage = randInt(weapon.min, weapon.max);

                    // Add damage level bonus
                    damage = Math.floor(damage + dmgBonus);

                    let isCrit = Math.random() <= CRIT_CHANCE;

                    if (isCrit) {
                        // Crit: max damage + bonus/2, bypasses armor
                        damage = Math.floor(weapon.max + dmgBonus / 2.0);
                        totalCrits++;
                        log.push({ t: time, type: 'crit', dmg: damage });
                    } else {
                        // AR absorption
                        const minAbsorb = Math.floor(effectiveAR / 4.3);
                        const maxAbsorb = Math.floor(effectiveAR / 2.4);
                        let absorbed = randInt(minAbsorb, maxAbsorb);

                        // 20% chance: low absorption (divided by 1.5)
                        if (Math.random() <= 0.2) {
                            absorbed = Math.floor(absorbed / 1.5);
                        }

                        totalMitigated += absorbed;
                        damage = Math.max(0, damage - absorbed);
                        log.push({ t: time, type: 'hit', dmg: damage, absorbed: absorbed });
                    }

                    // Reactive Armor: absorb 20% from pool
                    if (buffs.reactive && reactivePool > 0 && damage > 0) {
                        const mitigate = Math.min(Math.floor(damage * 0.2), reactivePool);
                        reactivePool -= mitigate;
                        damage -= mitigate;
                        totalReactiveAbsorbed += mitigate;
                        if (mitigate > 0) {
                            log.push({ t: time, type: 'reactive', absorbed: mitigate, poolLeft: reactivePool });
                        }
                    }

                    totalDamage += damage;
                    hp -= damage;
                    if (hp < 0) hp = 0;
                    hpTimeline.push({ t: time, hp: hp });

                    if (hp <= 0) {
                        log.push({ t: time, type: 'kill' });
                        break;
                    }

                    nextSwing += swingTime;
                }

                // Process bandage
                if (Math.abs(time - nextBandage) < 0.001 && time <= DURATION && hp > 0) {
                    const healAmount = randInt(5, 45);
                    const actualHeal = Math.min(healAmount, targetHP - hp);
                    hp += actualHeal;
                    totalHealed += actualHeal;
                    log.push({ t: time, type: 'heal', heal: actualHeal });
                    hpTimeline.push({ t: time, hp: hp });
                    nextBandage += BANDAGE_INTERVAL;
                }
            }

            // Final HP at t=60 if still alive
            if (hp > 0 && time < DURATION) {
                hpTimeline.push({ t: DURATION, hp: hp });
            }

            const simDuration = Math.min(hp <= 0 ? time : DURATION, DURATION);
            return {
                killed: hp <= 0,
                timeOfDeath: hp <= 0 ? time : null,
                finalHP: hp,
                totalDamage,
                totalHealed,
                totalMitigated,
                totalReactiveAbsorbed,
                totalCrits,
                totalSwings,
                totalHits,
                totalMisses,
                dps: totalDamage / simDuration,
                hps: totalHealed / simDuration,
                hitRate: totalSwings > 0 ? totalHits / totalSwings : 0,
                log,
                hpTimeline
            };
        }

        // ========== AUDIO ==========
        const combatSounds = [
            new Audio('sword_combat_%231-1772007797355.mp3'),
            new Audio('Sword_swings_%233-1772007886928.mp3'),
            new Audio('Armor_clank_combat_%233-1772007854432.mp3')
        ];
        const victorySfx = new Audio('Victory_trumpet_medi_%234-1772007552480.mp3');
        const defeatSfx = new Audio('sad_defeat_trumpet_m_%234-1772007661285.mp3');

        // Preload
        combatSounds.forEach(s => { s.volume = 0.5; s.load(); });
        victorySfx.volume = 0.6; victorySfx.load();
        defeatSfx.volume = 0.6; defeatSfx.load();

        let activeCombatSounds = [];

        function playRandomCombatSound() {
            const snd = combatSounds[Math.floor(Math.random() * combatSounds.length)];
            const clone = snd.cloneNode();
            clone.volume = 0.3 + Math.random() * 0.3;
            clone.play().catch(() => { });
            activeCombatSounds.push(clone);
        }

        function stopAllCombatSounds() {
            activeCombatSounds.forEach(s => { s.pause(); s.currentTime = 0; });
            activeCombatSounds = [];
        }

        function runSimulation() {
            const btn = document.getElementById('btnSimulate');
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';

            // Hide previous results
            document.getElementById('results').classList.remove('visible');

            // Show loading overlay
            const overlay = document.getElementById('loadingOverlay');
            const bar = document.getElementById('loadingBar');
            const pct = document.getElementById('loadingPercent');
            const details = document.getElementById('loadingDetails');
            overlay.classList.add('active');
            bar.style.width = '0%';
            pct.textContent = '0%';

            // Start combat sounds
            stopAllCombatSounds();
            playRandomCombatSound();
            const sfxInterval = setInterval(() => {
                playRandomCombatSound();
            }, 800 + Math.random() * 1200);

            const loadingMessages = [
                'Preparando combate...',
                'Calculando swing speed...',
                'Rolando dados de dano...',
                'Verificando hit chance...',
                'Aplicando absor√ß√£o de AR...',
                'Processando cr√≠ticos...',
                'Simulando bandagens...',
                'Analisando reactive armor...',
                'Compilando estat√≠sticas...',
                'Finalizando simula√ß√£o...'
            ];

            let progress = 0;
            const totalDuration = 5000;
            const interval = 50;
            const steps = totalDuration / interval;
            let step = 0;

            const loadingInterval = setInterval(() => {
                step++;
                const raw = step / steps;
                progress = raw < 0.5
                    ? 2 * raw * raw
                    : 1 - Math.pow(-2 * raw + 2, 2) / 2;
                const displayPct = Math.min(Math.floor(progress * 100), 99);
                bar.style.width = displayPct + '%';
                pct.textContent = displayPct + '%';

                const msgIdx = Math.min(Math.floor(progress * loadingMessages.length), loadingMessages.length - 1);
                details.textContent = loadingMessages[msgIdx];

                if (step >= steps) {
                    clearInterval(loadingInterval);
                    clearInterval(sfxInterval);
                    stopAllCombatSounds();

                    const simResults = executeSimulation();
                    bar.style.width = '100%';
                    pct.textContent = '100%';
                    details.textContent = '‚úì Simula√ß√£o conclu√≠da!';

                    setTimeout(() => {
                        overlay.classList.remove('active');
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                        displayResults(simResults);
                    }, 400);
                }
            }, interval);
        }

        function executeSimulation() {
            const weapon = WEAPONS[document.getElementById('weaponSelect').value];
            const ar = parseInt(document.getElementById('arInput').value) || 0;
            const targetHP = parseInt(document.getElementById('hpInput').value) || 100;
            const dex = parseInt(document.getElementById('dexInput').value) || 100;
            const weaponSkill = parseFloat(document.getElementById('weaponSkillInput').value) || 100;
            const tactics = parseFloat(document.getElementById('tacticsInput').value) || 100;
            const accuracyLvl = parseInt(document.getElementById('accuracyLevel').value) || 0;
            const damageLvl = parseInt(document.getElementById('damageLevel').value) || 0;

            // Monte Carlo: 1000 simulations
            const N = 1000;
            let kills = 0;
            let sumDPS = 0, sumHPS = 0, sumDmg = 0, sumHeal = 0, sumMit = 0, sumReactive = 0;
            let sumCrits = 0, sumSwings = 0, sumHits = 0, sumMisses = 0, sumHitRate = 0;
            let sumDeathTime = 0;
            let bestLog = null;

            for (let i = 0; i < N; i++) {
                const r = simulateOnce(weapon, ar, targetHP, dex, weaponSkill, tactics, accuracyLvl, damageLvl);
                if (r.killed) { kills++; sumDeathTime += r.timeOfDeath; }
                sumDPS += r.dps;
                sumHPS += r.hps;
                sumDmg += r.totalDamage;
                sumHeal += r.totalHealed;
                sumMit += r.totalMitigated;
                sumReactive += r.totalReactiveAbsorbed;
                sumCrits += r.totalCrits;
                sumSwings += r.totalSwings;
                sumHits += r.totalHits;
                sumMisses += r.totalMisses;
                sumHitRate += r.hitRate;
                if (i === 0) bestLog = r;
            }

            const killRate = kills / N;
            const avgDPS = sumDPS / N;
            const avgHPS = sumHPS / N;
            const avgDmg = sumDmg / N;
            const avgHeal = sumHeal / N;
            const avgMit = sumMit / N;
            const avgReactive = sumReactive / N;
            const avgCrits = sumCrits / N;
            const avgSwings = sumSwings / N;
            const avgHits = sumHits / N;
            const avgMisses = sumMisses / N;
            const avgHitRate = sumHitRate / N;
            const avgDeathTime = kills > 0 ? sumDeathTime / kills : null;

            return {
                weapon, ar, targetHP, killRate, avgDPS, avgHPS, avgDmg, avgHeal,
                avgMit, avgReactive, avgCrits, avgSwings, avgHits, avgMisses,
                avgHitRate, avgDeathTime, bestLog, N
            };
        }

        // ========== DISPLAY ==========
        function displayResults(r) {
            const res = document.getElementById('results');
            res.classList.add('visible');

            // Verdict
            const verdict = document.getElementById('verdict');
            const isKill = r.killRate >= 0.5;
            verdict.className = 'verdict-bar ' + (isKill ? 'kill' : 'survive');

            // Play verdict sound
            if (isKill) {
                victorySfx.currentTime = 0;
                victorySfx.play().catch(() => { });
            } else {
                defeatSfx.currentTime = 0;
                defeatSfx.play().catch(() => { });
            }

            if (isKill) {
                verdict.innerHTML = `‚ò†Ô∏è ALVO ELIMINADO` +
                    `<div class="verdict-sub">${(r.killRate * 100).toFixed(1)}% de chance de matar ‚Äî Tempo m√©dio: ${r.avgDeathTime?.toFixed(1) ?? '?'}s</div>`;
            } else {
                verdict.innerHTML = `üõ°Ô∏è ALVO SOBREVIVE` +
                    `<div class="verdict-sub">${(r.killRate * 100).toFixed(1)}% de chance de matar ‚Äî HP restante m√©dio: ${r.bestLog.finalHP}</div>`;
            }

            // Stats
            const effectiveAR = r.ar + (buffs.protection ? 10 : 0);
            document.getElementById('statsGrid').innerHTML = `
    <div class="stat-card"><div class="stat-val accent">${r.avgDPS.toFixed(1)}</div><div class="stat-lbl">DPS M√©dio</div></div>
    <div class="stat-card"><div class="stat-val gold">${r.avgHPS.toFixed(1)}</div><div class="stat-lbl">HPS (Bandagens)</div></div>
    <div class="stat-card"><div class="stat-val cyan">${r.avgMit.toFixed(0)}</div><div class="stat-lbl">Mitigado (AR)</div></div>
    <div class="stat-card"><div class="stat-val red">${r.avgDmg.toFixed(0)}</div><div class="stat-lbl">Dano Total</div></div>
    <div class="stat-card"><div class="stat-val green">${r.avgHeal.toFixed(0)}</div><div class="stat-lbl">Cura Total</div></div>
    <div class="stat-card"><div class="stat-val accent">${effectiveAR}</div><div class="stat-lbl">AR Efetivo</div></div>
    <div class="stat-card"><div class="stat-val gold">${r.avgCrits.toFixed(1)}</div><div class="stat-lbl">Cr√≠ticos</div></div>
    <div class="stat-card"><div class="stat-val green">${(r.avgHitRate * 100).toFixed(1)}%</div><div class="stat-lbl">Hit Rate</div></div>
    <div class="stat-card"><div class="stat-val">${r.avgHits.toFixed(0)}/${r.avgSwings.toFixed(0)}</div><div class="stat-lbl">Hits/Swings</div></div>
    <div class="stat-card"><div class="stat-val red">${r.avgMisses.toFixed(0)}</div><div class="stat-lbl">Misses</div></div>
    ${buffs.reactive ? `<div class="stat-card"><div class="stat-val cyan">${r.avgReactive.toFixed(1)}</div><div class="stat-lbl">React. Armor</div></div>` : ''}
  `;

            // Chart
            drawChart(r.bestLog.hpTimeline, r.targetHP);

            // Combat Log
            const logEl = document.getElementById('combatLog');
            logEl.innerHTML = r.bestLog.log.map(e => {
                const ts = `[${e.t.toFixed(2)}s]`;
                switch (e.type) {
                    case 'hit': return `${ts} ‚öîÔ∏è Dano: <b>${e.dmg}</b> (absorvido: ${e.absorbed})`;
                    case 'crit': return `<span class="log-crit">${ts} üí• CR√çTICO! Dano: <b>${e.dmg}</b> (ignora armadura)</span>`;
                    case 'heal': return `<span class="log-heal">${ts} ü©π Bandagem curou: +${e.heal} HP</span>`;
                    case 'reactive': return `<span class="log-absorb">${ts} ‚ö° Reactive Armor absorveu: ${e.absorbed} (pool: ${e.poolLeft})</span>`;
                    case 'miss': return `<span class="log-miss">${ts} üí® MISS (chance: ${(e.chance * 100).toFixed(1)}%)</span>`;
                    case 'kill': return `<span class="log-kill">${ts} ‚ò†Ô∏è ALVO MORTO!</span>`;
                    default: return '';
                }
            }).join('<br>');

            document.getElementById('simCount').textContent = `Resultado de 1 simula√ß√£o detalhada + m√©dia de ${r.N} simula√ß√µes Monte Carlo`;
            res.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // ========== CHART (pure Canvas) ==========
        function drawChart(timeline, maxHP) {
            const canvas = document.getElementById('hpChart');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            const W = rect.width;
            const H = rect.height;

            const pad = { t: 20, r: 20, b: 35, l: 50 };
            const gW = W - pad.l - pad.r;
            const gH = H - pad.t - pad.b;

            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#12121a';
            ctx.fillRect(0, 0, W, H);

            // Grid
            ctx.strokeStyle = '#2a2a40';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 5; i++) {
                const y = pad.t + (gH / 5) * i;
                ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(W - pad.r, y); ctx.stroke();
            }
            for (let i = 0; i <= 6; i++) {
                const x = pad.l + (gW / 6) * i;
                ctx.beginPath(); ctx.moveTo(x, pad.t); ctx.lineTo(x, H - pad.b); ctx.stroke();
            }

            // Axes labels
            ctx.fillStyle = '#555570';
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 6; i++) {
                ctx.fillText((i * 10) + 's', pad.l + (gW / 6) * i, H - pad.b + 16);
            }
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = Math.round(maxHP - (maxHP / 5) * i);
                ctx.fillText(val, pad.l - 8, pad.t + (gH / 5) * i + 4);
            }

            ctx.fillStyle = '#8888aa';
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('Tempo', W / 2, H - 2);

            ctx.save();
            ctx.translate(12, H / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('HP', 0, 0);
            ctx.restore();

            function toX(t) { return pad.l + (t / 60) * gW; }
            function toY(hp) { return pad.t + (1 - hp / maxHP) * gH; }

            // Gradient fill
            const grad = ctx.createLinearGradient(0, pad.t, 0, H - pad.b);
            grad.addColorStop(0, 'rgba(124,92,252,0.25)');
            grad.addColorStop(1, 'rgba(124,92,252,0.02)');

            ctx.beginPath();
            ctx.moveTo(toX(timeline[0].t), toY(0));
            timeline.forEach(p => ctx.lineTo(toX(p.t), toY(Math.max(0, p.hp))));
            ctx.lineTo(toX(timeline[timeline.length - 1].t), toY(0));
            ctx.closePath();
            ctx.fillStyle = grad;
            ctx.fill();

            // Line
            ctx.beginPath();
            timeline.forEach((p, i) => {
                const x = toX(p.t);
                const y = toY(Math.max(0, p.hp));
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.strokeStyle = '#7c5cfc';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Death marker
            const lastPoint = timeline[timeline.length - 1];
            if (lastPoint.hp <= 0) {
                const x = toX(lastPoint.t);
                const y = toY(0);
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
                ctx.strokeStyle = '#ef444480';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 11px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('‚ò†Ô∏è ' + lastPoint.t.toFixed(1) + 's', x, y - 14);
            }

            // Zero line
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = '#ef444440';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad.l, toY(0));
            ctx.lineTo(W - pad.r, toY(0));
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ========== INIT ==========
        initWeaponSelect();
    </script>
</body>

</html>
